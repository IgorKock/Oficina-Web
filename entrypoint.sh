    #!/bin/bash
    set -e

    echo "Aguardando o MariaDB iniciar em db:3306..."
    # 'wait-for-it.sh' é um script simples para esperar que um host:porta esteja disponível.
    # Ele será baixado e adicionado ao container no Dockerfile.
    /usr/bin/wait-for-it.sh db:3306 --timeout=60 --strict -- echo "MariaDB iniciou!"

    echo "Verificando e aplicando migrações de banco de dados..."

    # Define a variável de ambiente FLASK_APP para que os comandos Flask funcionem
    export FLASK_APP=run.py

    # Verifica se a pasta de migrações existe.
    # Se não existir, significa que é a primeira execução ou que a pasta não foi copiada.
    if [ ! -d "/app/migrations" ]; then
      echo "Pasta 'migrations' não encontrada. Inicializando Flask-Migrate e criando migração inicial..."
      flask db init
      flask db migrate -m "Initial migration (auto-generated by Docker entrypoint)"
      echo "Flask-Migrate inicializado e migração inicial criada."
    else
      echo "Pasta 'migrations' encontrada. Verificando se há novas migrações."
      # É importante notar que 'flask db migrate' irá criar um novo arquivo de migração
      # sempre que houver mudanças nos seus modelos, o que pode acumular muitos arquivos
      # se você reconstruir a imagem Docker frequentemente sem gerenciar as migrações localmente.
      # Para ambientes de produção, é mais comum gerar as migrações localmente e copiá-las.
      # No entanto, para auto-configuração, esta é uma abordagem viável.
      flask db migrate -m "Auto-generated migration on container startup" || true
      # Adicionamos '|| true' para que o script não falhe se não houver mudanças nos modelos
      # e 'flask db migrate' não criar um novo arquivo de migração (e sair com código 1)
    fi

    echo "Aplicando todas as migrações pendentes..."
    flask db upgrade

    echo "Iniciando a aplicação Flask..."
    # 'exec' substitui o processo atual pelo comando, o que é bom para a gestão de sinais
    exec python3 run.py
    